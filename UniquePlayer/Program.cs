using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Noggog;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace UniquePlayer
{
    public class Program
    {
        static Lazy<Settings> Settings = null!;

        private static readonly Dictionary<string, string> BodyReferenceToBodyName = new()
        {
            { "CBBE Hands", "CBBE" },
            { "CBBE Body", "CBBE" },
            { "CBBE Feet", "CBBE" },
            { "TBD - Reference - Default Body", "TBD" },
        };

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddRunnabilityCheck(RunnabilityCheck)
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "UniquePlayer.esp")
                .Run(args);
        }

        private static void RunnabilityCheck(IRunnabilityState state)
        {
            var dataPath = state.Settings.DataFolderPath;
            if (Settings.Value.CustomBodyslideInstallPath)
            {
                dataPath = Settings.Value.BodySlideInstallPath;
            }
            BodySlidePaths(dataPath, out string outfitsPath, out string groupsPath);

            if (!(Directory.Exists(outfitsPath) && Directory.Exists(groupsPath)))
                throw new FileNotFoundException("Bodyslide installation not in default location, cannot proceed.");
        }

        private static void BodySlidePaths(string dataPath, out string outfitsPath, out string groupsPath)
        {
            var bodySlidePath = dataPath + "\\CalienteTools\\BodySlide\\";
            outfitsPath = bodySlidePath + "SliderSets";
            groupsPath = bodySlidePath + "SliderGroups";
        }

        public static readonly Dictionary<IFormLinkGetter<IRaceGetter>, IFormLinkGetter<IKeywordGetter>> vanillaRaceToActorProxyKeywords = new()
        {
            { Skyrim.Race.ArgonianRace, RaceCompatibility.Keyword.ActorProxyArgonian },
            { Skyrim.Race.BretonRace, RaceCompatibility.Keyword.ActorProxyBreton },
            { Skyrim.Race.DarkElfRace, RaceCompatibility.Keyword.ActorProxyDarkElf },
            { Skyrim.Race.HighElfRace, RaceCompatibility.Keyword.ActorProxyHighElf },
            { Skyrim.Race.ImperialRace, RaceCompatibility.Keyword.ActorProxyImperial },
            { Skyrim.Race.KhajiitRace, RaceCompatibility.Keyword.ActorProxyKhajiit },
            { Skyrim.Race.NordRace, RaceCompatibility.Keyword.ActorProxyNord },
            { Skyrim.Race.OrcRace, RaceCompatibility.Keyword.ActorProxyOrc },
            { Skyrim.Race.RedguardRace, RaceCompatibility.Keyword.ActorProxyRedguard },
            { Skyrim.Race.WoodElfRace, RaceCompatibility.Keyword.ActorProxyWoodElf },
        };

        public static readonly Dictionary<FormKey, FormKey> replacementPlayableRacesDict = new();

        public static readonly Dictionary<FormKey, FormKey> replacementHeadParts = new();
        public static readonly HashSet<FormKey> inspectedHeadParts = new();

        public static readonly Dictionary<string, string> replacementTexturePathDict = new();
        public static readonly Dictionary<FormKey, FormKey> replacementTextureSets = new();
        public static readonly HashSet<string> inspectedTexturePaths = new();

        public static readonly Dictionary<string, string> replacementMeshPathDict = new();
        public static readonly HashSet<string> inspectedMeshPaths = new();

        public static readonly HashSet<FormKey> presetCharacters = new();

        public static readonly HashSet<string> seenDirectories = new();

        public static readonly string[] meshSuffixesWithTriFiles = {
            "_1.nif",
            ".nif"
        };

        /// <returns>setA.Intersect(setB).Count</returns>
        private static int CountIntersect<T>(ISet<T> setA, ISet<T> setB)
        {
            if (setA.Count > setB.Count)
                return CountIntersect(setB, setA);
            return setA.Count(setB.Contains);
        }

        /// <summary>
        /// Edits a path to a mesh file using Skyrim's mesh path rules.
        /// </summary>
        /// <returns>$"Meshes/{injectedPath}/..."</returns>
        /// <param name="testPath">$"{injectedPath}/..."</param>
        public static string MangleMeshesPath(string originalPath, string injectedPath, out string testPath)
        {
            originalPath = originalPath.Replace('/', '\\');
            var indexOfMeshes = originalPath.IndexOf("Meshes\\", StringComparison.OrdinalIgnoreCase);
            if (indexOfMeshes >= 0)
                originalPath = originalPath[(indexOfMeshes + 7)..];
            testPath = $"{injectedPath}\\{originalPath}";
            return $"Meshes\\{testPath}";
        }

        public static void CopyAndModifyOutfitFiles(string dataPath)
        {
            if (Settings.Value.CustomBodyslideInstallPath)
            {
                dataPath = Settings.Value.BodySlideInstallPath;
            }
            BodySlidePaths(dataPath, out string outfitsPath, out string groupsPath);

            var outfitOutputFileName = "\\UniquePlayer.osp";
            var groupOutputFileName = "\\UniquePlayer.xml";

            var oldToNewOutfitNames = new Dictionary<string, string>();

            static XDocument? tryLoad(string path)
            {
                try
                {
                    return XDocument.Load(path, LoadOptions.PreserveWhitespace);
                }
                catch (Exception e)
                {
                    Console.WriteLine(e);
                    return null;
                }
            }

            var outfitsData = (
                from filePath in Directory.GetFiles(outfitsPath).AsParallel()
                where filePath.EndsWith(".osp")
                  && !filePath.EndsWith(outfitOutputFileName)
                where File.Exists(filePath)
                let doc = tryLoad(filePath)
                where doc is not null
                let sliderSets = doc.Element("SliderSetInfo")?.Elements("SliderSet")
                where sliderSets is not null
                from sliderSet in sliderSets
                let name = sliderSet.GetAttribute("name")
                where name is not null
                group sliderSet by name
            ).ToDictionary(x => x.Key, x => x.First());

            var outfitsDoc = new XDocument(
                new XDeclaration("1.0", "utf-8", "yes")
            );
            var sliderSetInfo = new XElement("SliderSetInfo", new XAttribute("version", "1"));
            outfitsDoc.Add(sliderSetInfo);

            Dictionary<string, HashSet<string>> uniquePlayerOutfits = new();

            var bodyNameToSliderNameSets = new Dictionary<string, ImmutableHashSet<string>>();

            foreach (var (outfitName, bodyName) in BodyReferenceToBodyName)
            {
                if (!outfitsData.TryGetValue(outfitName, out var outfitData)) continue;

                bodyNameToSliderNameSets[bodyName] = outfitData
                    .Elements("Slider")
                    .Select(e => e.GetAttribute("name"))
                    .NotNull()
                    .ToImmutableHashSet();
            }

            var outfitNameToBodyName = new Dictionary<string, string>();

            foreach (var (oldOutfitName, outfitData) in outfitsData)
            {
                var outfitPathElement = outfitData.Element("OutputPath");
                if (outfitPathElement is null) continue;
                outfitPathElement.Value = MangleMeshesPath(outfitPathElement.Value, "Player", out _);

                if (!BodyReferenceToBodyName.TryGetValue(oldOutfitName, out var bodyName))
                {
                    var sliderNames = outfitData
                        .Elements("Slider")
                        .Select(e => e.GetAttribute("name"))
                        .NotNull()
                        .ToImmutableHashSet();

                    var highestCount = 0;
                    bodyName = "unknown";

                    foreach (var (candidateBodyName, candidateSliderNames) in bodyNameToSliderNameSets)
                    {
                        var matchCount = CountIntersect(sliderNames, candidateSliderNames);

                        if (matchCount > highestCount)
                        {
                            highestCount = matchCount;
                            bodyName = candidateBodyName;
                        }
                    }
                }

                var hasSMP = outfitData
                    .Elements("Shape")?
                    .Select(x => x.GetAttribute("target"))
                    .NotNull()
                    .Any(x => x.StartsWith("Virtual")) == true;

                var bodyNamePlusSMP = bodyName;

                if (hasSMP)
                    bodyNamePlusSMP += "-SMP";

                outfitNameToBodyName[oldOutfitName] = bodyNamePlusSMP;

                var newOutfitName = oldOutfitName;
                if (!oldOutfitName.Contains(bodyName))
                    newOutfitName += $" ({bodyName})";
                if (hasSMP && !oldOutfitName.Contains("SMP"))
                    newOutfitName += $" (SMP)";
                newOutfitName += " (Unique Player)";

                outfitData.Attribute("name")!.Value = newOutfitName;

                sliderSetInfo.Add(outfitData);
                oldToNewOutfitNames[oldOutfitName] = newOutfitName;

                if (!uniquePlayerOutfits.TryGetValue(bodyNamePlusSMP, out var uniquePlayerOutfitsForBodyName))
                    uniquePlayerOutfitsForBodyName = uniquePlayerOutfits[bodyNamePlusSMP] = new();
                uniquePlayerOutfitsForBodyName.Add(newOutfitName);
            }

            var outfitGroups =
                from filePath in Directory.GetFiles(groupsPath)//.AsParallel()
                where filePath.EndsWith(".xml")
                   && !filePath.EndsWith(groupOutputFileName)
                where File.Exists(filePath)
                let doc = tryLoad(filePath)
                where doc is not null
                let outfitGroups2 = doc.Element("SliderGroups")?.Elements("Group")
                where outfitGroups2 is not null
                from outfitGroup in outfitGroups2
                let outfitGroupName = outfitGroup.GetAttribute("name")
                where outfitGroupName is not null
                from outfitGroupMember in outfitGroup.Elements("Member")
                where outfitGroupMember is not null
                let outfitName = outfitGroupMember.GetAttribute("name")
                where outfitName is not null
                join rec in outfitNameToBodyName // only includes existing outfit names
                on outfitName equals rec.Key
                let bodyName = rec.Value
                let newOutfitName = oldToNewOutfitNames[outfitName]
                group newOutfitName by (outfitGroupName, bodyName);

            var sliderGroupDoc = new XDocument();
            var sliderGroups = new XElement("SliderGroups");
            sliderGroupDoc.Add(sliderGroups);

            static XElement MakeSliderGroup(IEnumerable<string> outfitNames, string outfitGroupName)
            {
                var sliderGroup = new XElement("Group", new XAttribute("name", outfitGroupName));

                foreach (var outfitName in outfitNames.OrderBy(x => x))
                {
                    sliderGroup.Add(new XElement("Member", new XAttribute("name", outfitName)));
                }

                return sliderGroup;
            }

            foreach (var item in outfitGroups)
            {
                var (outfitGroupName, bodyName) = item.Key;

                if (!outfitGroupName.Contains(bodyName))
                    outfitGroupName += $" ({bodyName})";
                outfitGroupName += " (Unique Player)";

                sliderGroups.Add(MakeSliderGroup(item, outfitGroupName));
            }

            foreach (var item in (from item in outfitNameToBodyName
                                  group item.Key by item.Value))
            {
                sliderGroups.Add(MakeSliderGroup(item, $"Original ({item.Key})"));
            }

            foreach (var (bodyName, uniquePlayerOutfitsForBodyName) in uniquePlayerOutfits)
                sliderGroups.Add(MakeSliderGroup(uniquePlayerOutfitsForBodyName, $"Unique Player ({bodyName})"));

            outfitsDoc.Save(outfitsPath + outfitOutputFileName);
            sliderGroupDoc.Save(groupsPath + groupOutputFileName);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var outfitFilesTask = new Task(() => CopyAndModifyOutfitFiles(state.Settings.DataFolderPath));

            var linkCache = state.LinkCache;

            var playableRaceFormList = RaceCompatibility.FormList.PlayableRaceList.Resolve(state.LinkCache);
            var playableVampireRaceFormList = RaceCompatibility.FormList.PlayableVampireList.Resolve(state.LinkCache);

            var playableRaceFormLinks = playableRaceFormList.ContainedFormLinks.Select(x => new FormLink<IRaceGetter>(x.FormKey)).ToList();
            var playableVampireRaceFormLinks = playableVampireRaceFormList.ContainedFormLinks.Select(x => new FormLink<IRaceGetter>(x.FormKey)).ToList();

            if (playableRaceFormLinks.Count != playableVampireRaceFormLinks.Count)
                throw new Exception("The number of playable races and the number of playable vampire races does not match, cannot proceed.");

            outfitFilesTask.Start();

            var victimRaceFormKeys = playableRaceFormLinks.Select(x => x.FormKey.AsLinkGetter<IRaceGetter>()).Concat(playableVampireRaceFormLinks.Select(x => x.FormKey.AsLinkGetter<IRaceGetter>())).ToHashSet();

            var otherFormLists =
                from x in state.LoadOrder.PriorityOrder.WinningOverrides<IFormListGetter>()
                where !x.Equals(RaceCompatibility.FormList.PlayableRaceList)
                && !x.Equals(RaceCompatibility.FormList.PlayableVampireList)
                && x.ContainedFormLinks.Any(y => victimRaceFormKeys.Contains(y.FormKey.AsLink<IRaceGetter>()))
                select state.PatchMod.FormLists.GetOrAddAsOverride(x);

            var modifiedPlayableRaceFormList = state.PatchMod.FormLists.GetOrAddAsOverride(playableRaceFormList);
            var modifiedPlayableVampireRaceFormList = state.PatchMod.FormLists.GetOrAddAsOverride(playableVampireRaceFormList);

            var texturesPath = state.Settings.DataFolderPath + "\\Textures\\";
            var meshesPath = state.Settings.DataFolderPath + "\\Meshes\\";

            string? changeTexturePath(string? path, ref bool changed)
            {
                if (path is null) return null;
                if (inspectedTexturePaths.Contains(path)) return path;
                if (replacementTexturePathDict.TryGetValue(path, out var newPath))
                {
                    changed = true;
                    return newPath;
                }

                newPath = "Player\\Textures\\" + path;
                if (File.Exists(texturesPath + newPath))
                {
                    replacementTexturePathDict.Add(path, newPath);
                    changed = true;
                    return newPath;
                }
                inspectedTexturePaths.Add(path);
                return path;
            }

            string changeMeshPath(string path, ref bool changed)
            {
                //if (path is null) return null;
                if (inspectedMeshPaths.Contains(path)) return path;
                if (replacementMeshPathDict.TryGetValue(path, out var newPath))
                {
                    changed = true;
                    return newPath;
                }

                newPath = MangleMeshesPath(path, "Player", out var testPath);

                if (!File.Exists(meshesPath + testPath))
                {
                    inspectedMeshPaths.Add(path);
                    return path;
                }

                replacementMeshPathDict.Add(path, newPath);
                changed = true;

                return newPath;
            }

            bool updateTextureSet(IFormLinkGetter<ITextureSetGetter> textureSetFormLink, IMajorRecordCommonGetter rec)
            {
                if (textureSetFormLink.IsNull) return false;
                var textureSetFormKey = textureSetFormLink.FormKey;
                if (replacementTextureSets.ContainsKey(textureSetFormKey)) return true;
                if (!textureSetFormLink.TryResolve(state.LinkCache, out var txst))
                {
                    throw RecordException.Factory(new NullReferenceException($"Could not find referenced TXST {textureSetFormLink}"), rec);
                }

                var changed = false;
                changeTexturePath(txst.Diffuse, ref changed);
                changeTexturePath(txst.NormalOrGloss, ref changed);
                changeTexturePath(txst.EnvironmentMaskOrSubsurfaceTint, ref changed);
                changeTexturePath(txst.GlowOrDetailMap, ref changed);
                changeTexturePath(txst.Height, ref changed);
                changeTexturePath(txst.Environment, ref changed);
                changeTexturePath(txst.Multilayer, ref changed);
                changeTexturePath(txst.BacklightMaskOrSpecular, ref changed);

                if (!changed) return false;

                var newTxst = state.PatchMod.TextureSets.AddNew($"{txst.EditorID}_UniquePlayer");
                newTxst.DeepCopyIn(txst, new TextureSet.TranslationMask(defaultOn: true)
                {
                    EditorID = false
                });
                replacementTextureSets.Add(textureSetFormKey, newTxst.FormKey);

                newTxst.Diffuse = changeTexturePath(txst.Diffuse, ref changed);
                newTxst.NormalOrGloss = changeTexturePath(txst.NormalOrGloss, ref changed);
                newTxst.EnvironmentMaskOrSubsurfaceTint = changeTexturePath(txst.EnvironmentMaskOrSubsurfaceTint, ref changed);
                newTxst.GlowOrDetailMap = changeTexturePath(txst.GlowOrDetailMap, ref changed);
                newTxst.Height = changeTexturePath(txst.Height, ref changed);
                newTxst.Environment = changeTexturePath(txst.Environment, ref changed);
                newTxst.Multilayer = changeTexturePath(txst.Multilayer, ref changed);
                newTxst.BacklightMaskOrSpecular = changeTexturePath(txst.BacklightMaskOrSpecular, ref changed);
                return true;
            }

            void updateHeadPart(IFormLinkGetter<IHeadPartGetter> headPartItem, IMajorRecordCommonGetter race)
            {
                var headPartFormKey = headPartItem.FormKey;
                if (replacementHeadParts.ContainsKey(headPartFormKey)) return;
                if (inspectedHeadParts.Contains(headPartFormKey)) return;
                var headPart = headPartItem.Resolve(state.LinkCache);
                if (headPart == null) throw RecordException.Factory(new NullReferenceException($"Could not find referenced HDPT {headPartFormKey}"), race);

                var changed = false;

                if (!headPart.TextureSet.IsNull)
                    changed |= updateTextureSet(headPart.TextureSet, headPart);

                headPart.Parts.ForEach(x =>
                {
                    if (x.FileName != null) changeMeshPath(x.FileName, ref changed);
                });

                if (headPart.Model != null)
                    changeMeshPath(headPart.Model.File, ref changed);

                headPart.Model?.AlternateTextures?.ForEach(x =>
                {
                    changed |= updateTextureSet(x.NewTexture, headPart);
                });

                headPart.ExtraParts.ForEach(x =>
                {
                    updateHeadPart(x, headPart);
                });

                if (!changed)
                {
                    inspectedHeadParts.Add(headPartFormKey);
                    return;
                };

                var newHeadPart = state.PatchMod.HeadParts.AddNew($"{headPart.EditorID}_UniquePlayer");
                newHeadPart.DeepCopyIn(headPart, new HeadPart.TranslationMask(defaultOn: true)
                {
                    EditorID = false
                });
                // TODO duplicate headPart FormList and restrict to player only?

                newHeadPart.Parts.ForEach(x =>
                {
                    if (x.FileName != null) x.FileName = changeMeshPath(x.FileName, ref changed);
                });

                if (newHeadPart.Model != null)
                    newHeadPart.Model.File = changeMeshPath(newHeadPart.Model.File, ref changed);

                newHeadPart.RemapLinks(replacementTextureSets);
                replacementHeadParts.Add(headPartFormKey, newHeadPart.FormKey);
            }

            Race copyRace(IRaceGetter oldRace)
            {
                var newRace = state.PatchMod.Races.AddNew($"{oldRace.EditorID}_UniquePlayer");
                newRace.DeepCopyIn(oldRace, new Race.TranslationMask(defaultOn: true)
                {
                    EditorID = false,
                    ArmorRace = false
                });
                newRace.MorphRace.SetTo(oldRace);
                replacementPlayableRacesDict.Add(oldRace.FormKey, newRace.FormKey);

                var race = newRace;

                race.HeadData?.NotNull().ForEach(headData =>
                {
                    headData.FaceDetails.NotNull().ForEach(x => updateTextureSet(x, race));

                    headData.HeadParts.NotNull().ForEach(x => updateHeadPart(x.Head, oldRace));

                    foreach (var item in headData.TintMasks)
                    {
                        var junk = false;
                        item.FileName = changeTexturePath(item.FileName, ref junk);
                    }

                    presetCharacters.Add(headData.RacePresets.Select(x => x.FormKey));
                });
                race.RemapLinks(replacementTextureSets);
                race.RemapLinks(replacementHeadParts);

                return newRace;
            }

            Console.WriteLine("Creating new player-only races from existing playable races.");
            foreach (var (raceLink, vampireRaceLink) in playableRaceFormLinks.Zip(playableVampireRaceFormLinks))
            {
                var race = raceLink.Resolve(linkCache);
                var vampireRace = vampireRaceLink.Resolve(linkCache);

                if (!race.Flags.HasFlag(Race.Flag.Playable))
                    throw RecordException.Factory(new Exception("Race in PlayableRaceList was not playable"), race);

                var newRace = copyRace(race);

                // add ActorProxy<race> for copies of vanilla races; it's assumed that either the non-vanilla race already has the appropriate ActorProxy<race>, or is happy with no ActorProxy<race>, and our copy should be the same.
                if (vanillaRaceToActorProxyKeywords.TryGetValue(raceLink, out var actorProxyKeywordFormKey))
                    (newRace.Keywords ??= new()).Add(actorProxyKeywordFormKey);

                var newVampireRace = copyRace(vampireRace);

                var modifiedRace = state.PatchMod.Races.GetOrAddAsOverride(race);
                modifiedRace.Flags ^= Race.Flag.Playable;
                modifiedRace.HeadData?.ForEach(x => x?.RacePresets.RemoveAll(x => true));

                foreach (var otherFormList in otherFormLists)
                {
                    var formLinks = otherFormList.ContainedFormLinks;
                    if (formLinks.Any(x => x.FormKey == raceLink.FormKey))
                        otherFormList.Items.Add(newRace);
                    if (formLinks.Any(x => x.FormKey == vampireRaceLink.FormKey))
                        otherFormList.Items.Add(newVampireRace);
                }
            }

            Console.WriteLine("Replacing the list of playable races (as supported by RaceCompatability.esm) with the newly created races.");
            modifiedPlayableRaceFormList.RemapLinks(replacementPlayableRacesDict);
            modifiedPlayableVampireRaceFormList.RemapLinks(replacementPlayableRacesDict);

            Console.WriteLine("Changing Player's race to our newly created player-only Race");
            state.PatchMod.Npcs.GetOrAddAsOverride(Skyrim.Npc.Player.Resolve(state.LinkCache)).RemapLinks(replacementPlayableRacesDict);

            foreach (var item in presetCharacters)
            {
                state.PatchMod.Npcs.GetOrAddAsOverride(linkCache.Resolve<INpcGetter>(item)).RemapLinks(replacementPlayableRacesDict);
            }

            // TODO only do armor addons that are used by playable armor?
            Console.WriteLine("Creating new ArmorAddons that use player-specific meshes or editing existing ArmorAddons to support newly added races.");

            var armorAddonAdditions = new Dictionary<FormKey, FormKey>();

            foreach (var armorAddon in state.LoadOrder.PriorityOrder.WinningOverrides<IArmorAddonGetter>().Where(x => victimRaceFormKeys.Contains(x.Race) || x.AdditionalRaces.Any(y => victimRaceFormKeys.Contains(y))).ToList())
            {
                bool needsEdit = false;
                var races = armorAddon.AdditionalRaces.Append(armorAddon.Race);

                var replacementRaces = races.Where(x => victimRaceFormKeys.Contains(x)).Select(x => replacementPlayableRacesDict[x.FormKey]).ToList();

                void modelNeedsEdit(IModelGetter? model)
                {
                    if (model is null) return;
                    changeMeshPath(model.File, ref needsEdit);
                    model.AlternateTextures?.ForEach(alternateTexture => needsEdit |= updateTextureSet(alternateTexture.NewTexture, armorAddon));
                }

                void applyModelEdit(Model? model)
                {
                    if (model is null) return;
                    model.File = changeMeshPath(model.File, ref needsEdit);
                    // model.AlternateTextures covered by running RemapLinks at the top level.
                }

                armorAddon.FirstPersonModel?.ForEach(modelNeedsEdit);
                armorAddon.WorldModel?.ForEach(modelNeedsEdit);

                armorAddon.SkinTexture?.ForEach(x =>
                {
                    if (!x.IsNull) needsEdit |= updateTextureSet(x, armorAddon);
                });

                if (needsEdit)
                {
                    var newArmorAddon = state.PatchMod.ArmorAddons.AddNew($"{armorAddon.EditorID}_UniquePlayer");
                    newArmorAddon.DeepCopyIn(armorAddon, new ArmorAddon.TranslationMask(defaultOn: true)
                    {
                        EditorID = false,
                        Race = false,
                        AdditionalRaces = false
                    });
                    newArmorAddon.Race.SetTo(replacementRaces.First());
                    replacementRaces.Skip(1).ForEach(x => newArmorAddon.AdditionalRaces.Add(x));

                    newArmorAddon.FirstPersonModel?.ForEach(applyModelEdit);
                    newArmorAddon.WorldModel?.ForEach(applyModelEdit);

                    newArmorAddon.RemapLinks(replacementTextureSets);

                    armorAddonAdditions.Add(armorAddon.FormKey, newArmorAddon.FormKey);

                    // remove defaultRace from base armorAddons?
                    if (races.Contains(Skyrim.Race.DefaultRace) && false)
                    {
                        var modifiedArmorAddon = state.PatchMod.ArmorAddons.GetOrAddAsOverride(armorAddon);
                        if (modifiedArmorAddon.Race.Equals(Skyrim.Race.DefaultRace))
                        {
                            var firstRace = modifiedArmorAddon.AdditionalRaces.First().FormKey;
                            modifiedArmorAddon.Race.SetTo(firstRace);
                            modifiedArmorAddon.AdditionalRaces.Remove(firstRace);
                        }
                        else
                        {
                            modifiedArmorAddon.AdditionalRaces.Remove(Skyrim.Race.DefaultRace);
                        }
                    }
                }
                else
                    state.PatchMod.ArmorAddons.GetOrAddAsOverride(armorAddon).AdditionalRaces.AddRange(replacementRaces);
            }

            var armors =
                from armor in state.LoadOrder.PriorityOrder.WinningOverrides<IArmorGetter>()
                where (!armor.MajorFlags.HasFlag(Armor.MajorFlag.NonPlayable))
                && armor.TemplateArmor.IsNull
                && armor.Armature.Any(y => armorAddonAdditions.ContainsKey(y.FormKey))
                select state.PatchMod.Armors.GetOrAddAsOverride(armor);

            Console.WriteLine("Registering new ArmorAddons with Armors");
            foreach (var armor in armors)
                foreach (var item in armor.Armature.ToList())
                    if (armorAddonAdditions.TryGetValue(item.FormKey, out var value))
                        armor.Armature.Insert(0, new FormLink<IArmorAddonGetter>(value));

            outfitFilesTask.Wait();
        }
    }
}
